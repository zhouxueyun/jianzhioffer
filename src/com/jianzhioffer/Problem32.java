package com.jianzhioffer;

/**
 * 从1到n整数中1出现的次数:<br>
 * 输入一个整数 n，求从 1 到 n 这 n 个整数的十进制表示中 1 出现的次 数。例如输入 12，这些整数中包含 1 的数字有 1,10,11,12，1
 * 一共出现了 5 次。 <br>
 * 解题思路:<br>
 * 1 ~ N 中"1"的个数跟最高位有关，那我们换个角度思考，给定一个 N，我们分析 1~N 中的数在每一位上出现 1
 * 的次数的和，看看每一位上"1"出现的个数的和由什么决定。 <br>
 * 1 位数的情况:在解法二中已经分析过，大于等于 1 的时候，有 1 个，小于 1 就 没有。<br>
 * 2 位数的情况:N=13,个位数出现的 1 的次数为 2，分别为 1 和 11，十位数出现 1 的次数为 4，分别为 10,11,12,13，所以
 * f(N) = 2+4。N=23,个位数出现的 1 的 次数为 3，分别为 1，11，21，十位数出现 1 的次数为 10，分别为
 * 10~19，f(N)=3+10。 <br>
 * 由此我们发现，个位数出现 1 的次数不仅和个位数有关，和十位数也有关，如果个位数大于等于 1，则个位数出现 1 的次数为十位数的数字加 1;<br>
 * 如果个位数为 0，个位数出现 1 的次数等于十位数数字。<br>
 * 而十位数上出现 1 的次数也不仅和十位数相关，也和个位数相关:如果十位数字等于 1，则十位数上出现 1 的次数为 个位数的数字加 1，假如十位数大于
 * 1，则十位数上出现 1 的次数为 10。 <br>
 * 3 位数的情况: N=123，个位出现 1 的个数为 13:1,11,21，...，91,101,111,121。十位出现 1 的 个数为
 * 20:10~19,110~119。百位出现 1 的个数为 24:100~123。 <br>
 * 我们可以继续分析 4 位数，5 位数，推导出下面一般情况: 假设 N，我们要计算百位上出现 1
 * 的次数，将由三部分决定:百位上的数字，百位以上的数字，百位以下的数字。 <br>
 * 如果百位上的数字为 0，则百位上出现 1 的次数仅由更高位决定，比如 12013， 百位出现 1 的情况为
 * 100~199,1100~1199,2100~2199，...，11100~11199，共 1200 个。等于更高位数字乘以当前位数，即 12 *
 * 100。 <br>
 * 如果百位上的数字大于 1，则百位上出现 1 的次数仅由更高位决定，比如 12213， 百位出现 1 的情况为
 * 100~199,1100~1199,2100~2199，...，11100~11199， 12100~12199 共 1300 个。等于更高位数字加 1
 * 乘以当前位数，即(12 + 1)*100。 <br>
 * 如果百位上的数字为 1，则百位上出现 1 的次数不仅受更高位影响，还受低位影 响。例如 12113，受高位影响出现 1
 * 的情况:100~199,1100~1199,2100~2199，...， 11100~11199，共 1200 个，但它还受低位影响，出现 1 的情况是
 * 12100~12113， 共 114 个，等于低位数字 113+1。
 * 
 * @author zhouxueyun
 *
 */
public class Problem32 {

	public static void main(String[] args) {
		Problem32 test = new Problem32();
		System.out.println(test.countOne(12));
		System.out.println(test.countOne(123));
		System.out.println(test.countOne(21345));
	}

	public long countOne(long n) {
		long count = 0;// 记录“1”出现的次数
		long i = 1;
		long current = 0, after = 0, before = 0;
		while ((n / i) != 0) { // 从最低位开始，判断每一位可能出现的1的次数
			current = (n / i) % 10; // 当前位数字
			before = n / (i * 10); // 高位数字
			after = n - (n / i) * i; // 低位数字
			if (current > 1)
				count = count + (before + 1) * i; // 大于1，高位为"0~before"都会出现1
			else if (current == 0)
				count = count + before * i;// 等于0，高位为"0~(before-1)"都会出现1
			else if (current == 1)
				count = count + before * i + (after + 1); // 等于1，高位为"0~(before-1)"都会出现1，且需要加上高位为before时低位从0~after出现的1
			i = i * 10;
		}
		return count;
	}

}
